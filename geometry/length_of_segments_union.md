# Длина объединения отрезков на прямой за O (N log N)

Даны $`N`$ отрезков на прямой, т.е. каждый отрезок задаётся парой координат $`(x_1, x_2)`$.
Рассмотрим объединение этих отрезков и найдём его длину.

Алгоритм был предложен Кли (Klee) в 1977 году.
Алгоритм работает за $`O (N log N)`$. Было доказано,
что этот алгоритм является быстрейшим (асимптотически).

## Описание

Положим все координаты концов отрезков в массив `x` и отсортируем его по значению координаты.
Дополнительное условие при сортировке — при равенстве координат первыми должны идти левые
концы. Кроме того, для каждого элемента массива будем хранить, относится он к левому или
к правому концу отрезка. Теперь пройдёмся по всему массиву, имея счётчик `C` перекрывающихся
отрезков. Если `C` отлично от нуля, то к результату добавляем разницу $`x_i - x_{i - 1}`$. Если
текущий элемент относится к левому концу, то увеличиваем счётчик `C`, иначе уменьшаем его.

## Реализация

```js
function segmentsUnionMeasure(a) {
  const n = a.length;
  const x = new Array(n * 2);

  for (let i = 0; i < n; i++) {
    x[i * 2] = [a[i][0], false]; // начало отрезка
    x[i * 2 + 1] = [a[i][1], true]; // конец отрезка
  }

  x.sort((p1, p2) => p1[0] - p2[0]);

  let result = 0;
  let count = 0;

  for (let i = 0; i < n * 2; i++) {
    if (count > 0 && i > 0) {
      result += x[i][0] - x[i - 1][0];
    }
    
    if (x[i][1]) {
      count++;
    } else {
      count--;
    }
  }

  return result;
}

const segments = [
  [1, 3],
  [2, 5],
  [6, 8]
];

console.log(segmentsUnionMeasure(segments)); // Вывод: 6

```
