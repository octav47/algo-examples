# Нахождение наидлиннейшей возрастающей подпоследовательности

## Условие задачи
Дан массив из `n` чисел: $`a[0 \ldots n-1]`$

Требуется найти в этой последовательности строго возрастающую подпоследовательность наибольшей длины

Фактически необходимо найти последовательность индексов $`i_1 \ldots i_k`$, такую что

```math
i_1 < i_2 < \ldots < i_k,
```
```math
a[i_1] < a[i_2] < \ldots < a[i_k]
```

## Решение за `O(n^2)`: метод динамического программирования

Сначала решим задачу поиска длины наидлиннейшей возрастающей подпоследовательности,
а восстановлением самой подпоследовательности займёмся позже

### Динамическое программирование для поиска длины ответа

Научимся считать массив $`d[0 \ldots n-1]`$,
где $`d[i]`$ — это длина наидлиннейшей возрастающей подпоследовательности,
оканчивающейся именно в элементе с индексом `i`

Массив этот будем считать постепенно:
сначала $`d[0]`$, затем $`d[1]`$ и т.д

В конце, когда этот массив будет подсчитан, ответ на задачу будет равен максимуму в массиве $`d[]`$

Итак, пусть текущий индекс — `i`, т.е. мы хотим посчитать значение $`d[i]`$,
а все предыдущие значения $`d[0] \ldots d[i-1]`$ уже подсчитаны

Тогда заметим, что у нас есть два варианта:

* либо $`d[i] = 1`$, т.е. искомая подпоследовательность состоит только из числа $`a[i]`$
* либо $`d[i] > 1`$. Тогда перед числом $`a[i]`$ в искомой подпоследовательности стоит какое-то другое число. Это может быть любой элемент $`a[j] (j = 0 \ldots i-1)`$, но такой, что $`a[j] < a[i]`$. Пусть мы рассматриваем какой-то текущий индекс `j`. Поскольку динамика $`d[j]`$ для него уже подсчитана, получается, что это число $`a[j]`$ вместе с числом $`a[i]`$ даёт ответ $`d[j] + 1`$. Таким образом, $`d[i]`$ можно считать по такой формуле:
```math
d[i] = \max_{\atop j=0 \ldots i-1, a[j] < a[i]} (d[j] + 1)
```

Объединяя эти два варианта в один, получаем окончательный алгоритм для вычисления $`d[i]`$:

```math
d[i] = \max \Big(1, \max_{\atop j=0 \ldots i-1, a[j] < a[i]} (d[j] + 1) \Big)
```

Этот алгоритм — и есть сама динамика

### Реализация

Приведём реализацию описанного выше алгоритма,
которая находит и выводит длину наидлиннейшей возрастающей подпоследовательности:

```js
const MAXN = 1000; // Максимальное значение n (можно убрать, если не нужно)
const d = new Array(MAXN).fill(1); // массив длины наибольшей возрастающей подпоследовательности

for (let i = 0; i < n; i++) {
  d[i] = 1;
  
  for (let j = 0; j < i; j++) {
    if (a[j] < a[i]) {
      d[i] = Math.max(d[i], 1 + d[j]);
    }
  }
}

let [ans] = d;

for (let i = 0; i < n; i++) {
  ans = Math.max(ans, d[i]);
}

console.log(ans);
```

### Восстановление ответа

Пока мы научились искать лишь длину ответа,
но саму наидлиннейшую подпоследовательность мы вывести не можем,
т.к. не сохраняем никакой дополнительной информации о том, где достигаются максимумы

Чтобы восстановить ответ, помимо динамики $`d[0 \ldots n-1]`$ надо также хранить
вспомогательный массив $`p[0 \ldots n-1]`$, который покажет каком месте достигся максимум
для каждого значения $`d[i]`$

Иными словами, индекс `$p[i]`$ будет обозначать тот самый индекс `j`,
при котором получилось наибольшее значение $`d[i]`$

Этот массив $`p[]`$ в динамическом программировании часто называют «массивом предков»

Для того, чтобы вывести ответ, надо идти от элемента с максимальным
значением $`d[i]`$ по его предкам до тех пор, пока мы не выведем всю подпоследовательность,
т.е. пока не дойдём до элемента со значением $`d = 1`$

### Реализация восстановления ответа

Изменится код самой динамики и добавится код, производящий вывод
наидлиннейшей подпоследовательности (выводятся индексы элементов подпоследовательности, в 0-индексации)

Для удобства мы изначально положили индексы $`p[i] = -1`$: для элементов, у которых динамика
получилась равной единице, это значение предка так и останется
минус единицей, что удобнее при восстановлении ответа

```js
const MAXN = 1000; // Максимальное возможное значение n

const d = new Array(MAXN).fill(1); // массив длины наибольшей подпоследовательности
const p = new Array(MAXN).fill(-1); // массив предков для восстановления пути

for (let i = 0; i < n; i++) {
  d[i] = 1;
  p[i] = -1;
  
  for (let j = 0; j < i; j++) {
    if (a[j] < a[i] && 1 + d[j] > d[i]) {
      d[i] = 1 + d[j];
      p[i] = j;
    }
  }
}

let [ans] = d;
let pos = 0;

for (let i = 0; i < n; i++) {
  if (d[i] > ans) {
    ans = d[i];
    pos = i;
  }
}

console.log(ans);

let path = [];

while (pos !== -1) {
  path.push(pos);
  pos = p[pos];
}

path.reverse();
console.log(path.join(" "));
```

### Альтернативный способ восстановления ответа

Для восстановления ответа можно не хранить дополнительный
массив предков $`p[]`$, а просто заново пересчитать текущий элемент
динамики и найти, на каком же индексе был достигнут максимум

Этот способ при реализации приводит к более длинному коду,
однако взамен получаем экономию памяти и абсолютное совпадение
логики программы в процессе подсчёта динамики и в процессе восстановления

## Решение за O `(n log n)`: динамическое программирование с двоичным поиском

Для того, чтобы получить более быстрое решение задачи,
построим другой вариант динамического программирования за $`O (n^2)`$,
а затем поймём, как можно этот вариант ускорить до $`O (n \log n)`$

Динамика теперь будет такой: 
пусть $`d[i] (i = 0 \ldots n)`$ — это число, на которое оканчивается
возрастающая подпоследовательность длины `i` (если таких чисел несколько — то наименьшее из них)

Мы полагаем $`d[0] = -\infty`$, а все остальные элементы $`d[i] = \infty`$

Считать эту динамику мы будем постепенно, обработав число $`a[0]`$, затем $`a[1]`$, и т.д.

Приведём реализацию этой динамики за $`O (n^2)`$:

```js
const MAXN = 1000; // Максимальное возможное значение n
const INF = 1e9; // Значение, представляющее бесконечность
const d = new Array(MAXN + 1).fill(INF); // Массив d для хранения наименьших возможных значений

d[0] = -INF;

for (let i = 0; i < n; i++) {
  for (let j = 1; j <= n; j++) {
    if (d[j - 1] < a[i] && a[i] < d[j]) {
      d[j] = a[i];
    }
  }
}
```

У этой динамики есть одно очень важное
свойство: $`d[i-1] \le d[i]`$ для всех $`i = 1 \ldots n`$.
Другое свойство — каждый элемент $`a[i]`$ обновляет
максимум одну ячейку $`d[j]`$

Это означает,
что обрабатывать очередное $`a[i]`$ мы можем за $`O (\log n)`$,
сделав двоичный поиск по массиву $`d[]`$.
В самом деле, мы просто ищем в массиве $`d[]`$ первое число,
которое строго больше $`a[i]`$, и пытаемся произвести
обновление этого элемента аналогично приведённой выше реализации.

### Реализация за `O (n log n)`

```js
const MAXN = 1000; // Максимальное возможное значение n
const INF = 1e9; // Значение, представляющее бесконечность
const d = new Array(MAXN + 1).fill(INF); // Массив d для хранения наименьших возможных значений

d[0] = -INF;

for (let i = 0; i < n; i++) {
  // Находим индекс первого элемента, который строго больше a[i]
  let j = d.findIndex((val) => val > a[i]);

  if (d[j - 1] < a[i] && a[i] < d[j]) {
    d[j] = a[i];
  }
}
```

### Восстановление ответа

По такой динамике тоже можно восстановить ответ,
для этого опять, помимо динамики $`d[i]`$, надо
хранить «массив предков» $`p[i]`$, который покажет на элементе с каким
индексом оканчивается оптимальная подпоследовательность длины `i`.
Кроме того, для каждого элемента массива $`a[i]`$ надо будет хранить
его «предка» — индекс того элемента, который должен
стоять перед $`a[i]`$ в оптимальной подпоследовательности.

Поддерживая эти два массива по ходу вычисления
динамики, в конце будет нетрудно восстановить
искомую подпоследовательность

Интересно отметить, что применительно к данной динамике
ответ можно восстанавливать только через массивы
предков, без них восстановить ответ после вычисления
динамики будет невозможно. Это один из редких случаев, когда к динамике
неприменим альтернативный способ восстановления без массивов предков

## Решение за `O (n log n)`: структуры данных

Приведённый выше способ за $`O (n \log n)`$ весьма красив,
однако не совсем тривиален. Рассмотрим ещё один способ решения,
а именно воспользоваться одной из известных простых структур данных

В самом деле, давайте вернёмся к самой первой динамике,
где состоянием являлась просто текущая позиция. Текущее
значение динамики $`d[i]`$ вычисляется как максимум
значений $`d[i]`$ среди всех таких элементов `j`, что $`a[j] < a[i]`$

Следовательно, если мы через $`t[]`$ обозначим такой массив,
в который будем записывать значения динамики от чисел:

```math
t[a[i]] = d[i]
```

то получается, что всё, что нам надо уметь — это искать максимум
на префиксе массива `t`: $`t[0 \ldots a[i]-1]`$.

Задача поиска максимума на префиксах массива
(с учётом того, что массив может меняться) решается
многими стандартными структурами данных, например, деревом отрезков или деревом Фенвика

Воспользовавшись любой такой структурой данных,
мы получим решение за $`O (n \log n)`$

У этого способа решения есть явные недостатки:
по длине и сложности реализации этот путь будет в любом
случае хуже, чем описанная выше динамика за $`O (n \log n)`$.
Кроме того, если входные числа $`a[i]`$ могут быть достаточно
большими, то скорее всего их придётся сжимать (т.е. перенумеровывать
от 0 до n-1) — без этого многие стандартные структуры данных
работать не смогут из-за высокого потребления памяти

С другой стороны, у данного пути есть и преимущества.
Во-первых, при таком способе решения не придётся задумываться
о хитрой динамике. Во-вторых, этот способ позволяет решать
некоторые обобщения нашей задачи (о них см. ниже)

## Смежные задачи

Приведём здесь несколько задач, тесно связанных с задачей поиска
наидлиннейшей возрастающей подпоследовательности

### Наидлиннейшая неубывающая подпоследовательность

Фактически, это та же самая задача, только теперь в искомой
подпоследовательности допускаются одинаковые числа (т.е. мы должны
найти нестрого возрастающую подпоследовательность)

Решение этой задачи по сути ничем не отличается от нашей
исходной задачи, просто при сравнениях изменятся знаки неравенств,
а также надо будет немного изменить двоичный поиск

### Количество наидлиннейших возрастающих подпоследовательностей

Для решения этой задачи можно использовать самую
первую динамику за $`O (n^2)`$ либо подход с помощью структур
данных для решения за $`O (n \log n)`$

В обоих случаях
все изменения заключаются только в том, что помимо значения
динамики $`d[i]`$ надо также хранить сколькими способами
это значение могло быть получено

По всей видимости, способ решения через динамику за $`O (n \log n)`$ к данной задаче применить невозможно

### Наименьшее число невозрастающих подпоследовательностей, покрывающих данную последовательность

Условие таково. Дан массив из n чисел $`a[0 \ldots n-1]`$. Требуется раскрасить
его числа в наименьшее число цветов так, чтобы по каждому цвету получалась
бы невозрастающая подпоследовательность

#### Решение

Утверждается, что минимальное количество необходимых цветов равно
длине наидлиннейшей возрастающей подпоследовательности

#### Доказательство

Фактически, нам надо доказать двойственность этой задачи и
задачи поиска наидлиннейшей возрастающей подпоследовательности

Обозначим через `x` длину наидлиннейшей возрастающей подпоследовательности, а
через `y` — искомое наименьшее число невозрастающих подпоследовательностей
Нам нужно доказать, что $`x = y`$

С одной стороны, понятно, почему не может быть $`y < x`$: если у нас есть `x`
строго возрастающих элементов, то никакие два из них не могли попасть
в одну невозрастающую подпоследовательность, а, значит, $`y \ge x`$

Покажем теперь, что, наоборот, y не может быть $`> x`$. Докажем это от противного:
предположим, что $`y > x`$. Тогда рассмотрим любой оптимальный набор
из `y` невозрастающих подпоследовательностей. Преобразуем этот набор
таким образом: пока есть две таких подпоследовательности, что
первая начинается раньше второй, но при этом первая начинается с числа,
больше либо равного чем начало второй — отцепим это стартовое число от
первой подпоследовательности и прицепим в начало второй. Таким образом,
через какое-то конечное число шагов у нас останется y подпоследовательностей,
причём их стартовые числа будут образовывать возрастающую подпоследовательность
длины `y`. Но $`y > x`$, т.е. мы пришли к противоречию (ведь не может
быть возрастающих подпоследовательностей длиннее `x`)

Таким образом, в самом деле, $`y = x`$, что и требовалось доказать

#### Восстановление ответа

Утверждается, что само искомое разбиение на
подпоследовательности можно искать жадно, т.е. идя слева направо и относя текущее
число в ту подпоследовательность, которая сейчас заканчивается на минимальное число,
больше либо равное текущему

