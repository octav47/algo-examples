# Нахождение наидлиннейшей возрастающей подпоследовательности

<img src="https://latex.codecogs.com/gif.latex?" />

$``$

## Условие задачи
Дан массив из n чисел: $`a[0 \ldots n-1]`$.
Требуется найти в этой последовательности строго возрастающую подпоследовательность наибольшей длины

Фактически требуется найти такую последовательность
индексов $`i_1 \ldots i_k`$, такую что

```math
i_1 < i_2 < \ldots < i_k,
```
```math
a[i_1] < a[i_2] < \ldots < a[i_k]
```

## Решение за `O(n^2)`: метод динамического программирования

Научимся сначала искать длину наидлиннейшей возрастающей подпоследовательности,
а восстановлением самой подпоследовательности займёмся чуть позже

### Динамическое программирование для поиска длины ответа

Для этого давайте научимся считать массив $`d[0 \ldots n-1]`$,
где $`d[i]`$ — это длина наидлиннейшей возрастающей подпоследовательности,
оканчивающейся именно в элементе с индексом `i`.

Массив этот (он и есть — сама динамика) будем считать постепенно:
сначала $`d[0]`$, затем $`d[1]`$ и т.д.

В конце, когда этот массив будет подсчитан нами, ответ на задачу будет равен максимуму в массиве $`d[]`$.

Итак, пусть текущий индекс — `i`, т.е. мы хотим посчитать значение $`d[i]`$,
а все предыдущие значения $`d[0] \ldots d[i-1]`$ уже подсчитаны.

Тогда заметим, что у нас есть два варианта:

* либо $`d[i] = 1`$, т.е. искомая подпоследовательность состоит только из числа $`a[i]`$
* либо $`d[i] > 1`$. Тогда перед числом $`a[i]`$ в искомой подпоследовательности стоит какое-то другое число. Давайте переберём это число: это может быть любой элемент $`a[j] (j = 0 \ldots i-1)`$, но такой, что $`a[j] < a[i]`$. Пусть мы рассматриваем какой-то текущий индекс `j`. Поскольку динамика $`d[j]`$ для него уже подсчитана, получается, что это число $`a[j]`$ вместе с числом $`a[i]`$ даёт ответ $`d[j] + 1`$. Таким образом, $`d[i]`$ можно считать по такой формуле:
```math
d[i] = \max_{j=0 \ldots i-1, \atop a[j] < a[i]} ([...]
```

Объединяя эти два варианта в один, получаем окончательный алгоритм для вычисления $`d[i]`$:

```math
d[i] = \max \Big( 1, \max_{j=0 \ldots i-1, \atop [...]
```

Этот алгоритм — и есть сама динамика.

### Реализация

Приведём реализацию описанного выше алгоритма,
которая находит и выводит длину наидлиннейшей возрастающей подпоследовательности:

```js
const MAXN = 1000; // Максимальное значение n (можно убрать, если не нужно)
const d = new Array(MAXN).fill(1); // массив длины наибольшей возрастающей подпоследовательности

for (let i = 0; i < n; i++) {
  d[i] = 1;
  
  for (let j = 0; j < i; j++) {
    if (a[j] < a[i]) {
      d[i] = Math.max(d[i], 1 + d[j]);
    }
  }
}

let [ans] = d;

for (let i = 0; i < n; i++) {
  ans = Math.max(ans, d[i]);
}

console.log(ans);
```

### Восстановление ответа

Пока мы лишь научились искать длину ответа,
но саму наидлиннейшую подпоследовательность мы вывести не можем,
т.к. не сохраняем никакой дополнительной информации о том, где достигаются максимумы

Чтобы суметь восстановить ответ, помимо динамики $`d[0 \ldots n-1]`$ надо также хранить
вспомогательный массив $`p[0 \ldots n-1]`$ — то, в каком месте достигся максимум
для каждого значения $`d[i]`$

Иными словами, индекс `$p[i]`$ будет обозначать тот самый индекс `j`,
при котором получилось наибольшее значение $`d[i]`$

Этот массив $`p[]`$ в динамическом программировании часто называют "массивом предков"

Для того, чтобы вывести ответ, надо просто идти от элемента с максимальным
значением $`d[i]`$ по его предкам до тех пор, пока мы не выведем всю подпоследовательность,
т.е. пока не дойдём до элемента со значением $`d = 1`$.

### Реализация восстановления ответа

Итак, у нас изменится и код самой динамики, и добавится код, производящий вывод
наидлиннейшей подпоследовательности (выводятся индексы элементов подпоследовательности, в 0-индексации).

Для удобства мы изначально положили индексы $`p[i] = -1`$: для элементов, у которых динамика
получилась равной единице, это значение предка так и останется
минус единицей, что чуть-чуть удобнее при восстановлении ответа.

```js
const MAXN = 1000; // Максимальное возможное значение n

const d = new Array(MAXN).fill(1); // массив длины наибольшей подпоследовательности
const p = new Array(MAXN).fill(-1); // массив предков для восстановления пути

for (let i = 0; i < n; i++) {
  d[i] = 1;
  p[i] = -1;
  
  for (let j = 0; j < i; j++) {
    if (a[j] < a[i] && 1 + d[j] > d[i]) {
      d[i] = 1 + d[j];
      p[i] = j;
    }
  }
}

let [ans] = d;
let pos = 0;

for (let i = 0; i < n; i++) {
  if (d[i] > ans) {
    ans = d[i];
    pos = i;
  }
}

console.log(ans);

let path = [];

while (pos !== -1) {
  path.push(pos);
  pos = p[pos];
}

path.reverse();
console.log(path.join(" "));
```

### Альтернативный способ восстановления ответа

Впрочем, как почти всегда в случае динамического программирования,
для восстановления ответа можно не хранить дополнительный
массив предков $`p[]`$, а просто заново пересчитывая текущий элемент
динамики и ища, на каком же индексе был достигнут максимум.

Этот способ при реализации приводит к чуть более длинному коду,
однако взамен получаем экономию памяти и абсолютное совпадение
логики программы в процессе подсчёта динамики и в процессе восстановления.
