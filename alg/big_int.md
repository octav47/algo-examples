# Длинная арифметика

Длинная арифметика — это набор программных средств (структуры данных и алгоритмы),
которые позволяют работать с числами гораздо больших величин,
чем это позволяют стандартные типы данных

## Виды целочисленной длинной арифметики

### Классическая длинная арифметика

Основная идея заключается в том, что число хранится в виде массива его цифр

Цифры могут использоваться из той или иной системы счисления,
обычно применяются десятичная система счисления и её степени (десять тысяч, миллиард),
либо двоичная система счисления

Операции над числами в этом виде длинной арифметики производятся с помощью "школьных" алгоритмов сложения,
вычитания, умножения, деления столбиком. Впрочем, к ним также применимы алгоритмы быстрого умножения:
Быстрое преобразование Фурье и Алгоритм Карацубы

Здесь описана работа только с неотрицательными длинными числами.
Для поддержки отрицательных чисел необходимо ввести и поддерживать
дополнительный флаг "отрицательности" числа, либо же работать в дополняющих кодах

#### Структура данных

Хранить длинные числа будем в виде массива чисел number, где каждый элемент — это одна цифра числа

```js
const lnum = [];
```

Для повышения эффективности будем работать в системе по основанию миллиард,
т.е. каждый элемент массива `lnum` содержит не одну, а сразу 9 цифр:

```js
const base = 1000 * 1000 * 1000;
```

Кроме того, все операции будут реализованы таким образом,
что после выполнения любой из них лидирующие нули (т.е. лишние нули в начале числа)
отсутствуют (разумеется, в предположении, что перед каждой операцией лидирующие нули
также отсутствуют). Следует отметить, что в представленной реализации для числа ноль
корректно поддерживаются сразу два представления: пустой массив цифр, и массив цифр,
содержащий единственный элемент — ноль

#### Вывод

Самое простое — это вывод длинного числа.

Сначала мы просто выводим самый последний элемент
массива (или 0, если массив пустой), а затем выводим
все оставшиеся элементы массива, дополняя их нулями до 9 символов:

```js
// используем process.stdout.write вместо console.log, так как он добавляет \n автоматически

if (a.length === 0) {
  process.stdout.write('0');
} else {
  process.stdout.write(a[a.length - 1].toString());
  
  for (let i = a.length - 2; i >= 0; i--) {
    process.stdout.write(a[i].toString().padStart(9, "0"));
  }
}
```

#### Чтение

Считываем строку и преобразовываем её в массив:

```js
let a = [];

for (let i = s.length; i > 0; i -= 9) {
  if (i < 9) {
    a.push(parseInt(s.substring(0, i), 10));
  } else {
    a.push(parseInt(s.substring(i - 9, i), 10));
  }
}
```

Если во входном числе уже могут быть лидирующие нули,
то их после чтения можно удалить таким образом:

```js
while (a.length > 1 && a[a.length - 1] === 0) {
  a.pop();
}
```

#### Сложение

Прибавляет к числу a число b и сохраняет результат в a:

```js
let carry = 0;
let n = Math.max(a.length, b.length);

for (let i = 0; i < n || carry; i++) {
  if (i === a.length) {
    a.push(0);
  }
    
  a[i] += carry + (i < b.length ? b[i] : 0);
  carry = a[i] >= base ? 1 : 0;
    
  if (carry) {
    a[i] -= base;
  }
}

```

#### Вычитание

Отнимает от числа a число b $`(a \ge b)`$ и сохраняет результат в a:

```js
let carry = 0;

for (let i = 0; i < b.length || carry; i++) {
  a[i] -= carry + (i < b.length ? b[i] : 0);
  carry = a[i] < 0 ? 1 : 0;
    
  if (carry) {
    a[i] += base;
  }
}

while (a.length > 1 && a[a.length - 1] === 0) {
  a.pop();
}
```

Здесь мы после выполнения вычитания удаляем лидирующие нули,
чтобы поддерживать предикат о том, что таковые отсутствуют.

#### Умножение длинного на короткое

Умножает длинное a на короткое b $`(b < {\rm base})`$ и сохраняет результат в a:

```js
let carry = 0;

for (let i = 0; i < a.length || carry; i++) {
  if (i === a.length) {
    a.push(0);
  }
  
  let cur = carry + BigInt(a[i]) * BigInt(b);
  
  a[i] = Number(cur % BigInt(base));
  carry = Number(cur / BigInt(base));
}

while (a.length > 1 && a[a.length - 1] === 0) {
  a.pop();
}
```

Здесь мы после выполнения деления удаляем лидирующие нули,
чтобы поддерживать предикат о том, что таковые отсутствуют.

#### Умножение двух длинных чисел

Умножает a на b и результат сохраняет в c:

```js
let c = new Array(a.length + b.length).fill(0);

for (let i = 0; i < a.length; i++) {
  let carry = 0;
        
  for (let j = 0; j < b.length || carry; j++) {
    let cur = BigInt(c[i + j]) + BigInt(a[i]) * BigInt(j < b.length ? b[j] : 0) + BigInt(carry);
            
    c[i + j] = Number(cur % BigInt(base));
    carry = Number(cur / BigInt(base));
  }
}

while (c.length > 1 && c[c.length - 1] === 0) {
  c.pop();
}
```

#### Деление длинного на короткое

Делит длинное a на короткое b $`(b < {\rm base})`$, частное сохраняет в a, остаток в carry:

```js
let carry = 0;

for (let i = a.length - 1; i >= 0; i--) {
  let cur = BigInt(a[i]) + BigInt(carry) * BigInt(base);
  
  a[i] = Number(cur / BigInt(b));
  carry = Number(cur % BigInt(b));
}

while (a.length > 1 && a[a.length - 1] === 0) {
  a.pop();
}
```

### Длинная арифметика по системе простых модулей (Китайская теорема или схема Гарнера)

Суть в том, что выбирается некоторая система модулей (обычно небольших,
помещающихся в стандартные типы данных), и число хранится в виде массив из
остатков от его деления на каждый из этих модулей.

Как утверждает Китайская теорема об остатках, этого достаточно, чтобы
однозначно хранить любое число в диапазоне от 0 до произведения этих модулей
минус один. При этом имеется Алгоритм Гарнера, который позволяет произвести
это восстановление из модульного вида в обычную, "классическую", форму числа.

Таким образом, этот метод позволяет экономить память по сравнению с "классической"
длинной арифметикой (хотя в некоторых случаях не столь радикально, как метод
факторизации). Крому того, в модульном виде можно очень быстро производить
сложения, вычитания и умножения, — все за асимптотически однаковое время,
пропорциональное количеству модулей системы.

Однако всё это даётся ценой весьма трудоёмкого перевода числа из этого модульного
вида в обычный вид, для чего, помимо немалых временных затрат, потребуется
также реализация "классической" длинной арифметики с умножением.

Помимо этого, производить деление чисел в таком представлении по системе
простых модулей не представляется возможным.
