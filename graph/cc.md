# Поиск компонент связности в графе

Алгоритм позволяет найти компоненты связности,
то есть разбить граф на группы так,
что внутри одной группы можно дойти от одной вершины до другой,
а от вершин из разных групп — нет.

## Описание алгоритма

Для решения можно воспользоваться как [обходом в глубину](graph/dfs.md),
так и [обходом в ширину](graph/bfs.md).

Фактически мы будем производить серию обходов: сначала запустим обход из первой вершины,
и все вершины, которые он при этом обошёл, образуют первую компоненту связности.
Затем найдём первую из оставшихся вершин, которые ещё не были посещены,
и запустим обход из неё, найдя тем самым вторую компоненту связности, и так далее,
пока у нас есть вершины, которые мы ещё не обошли.

Алгоритм работает за `O(n+m)`, так как алгоритм не будет запускаться от одной и той же вершины дважды,
а следовательно каждое ребро будет просмотрено ровно два раза (с одного конца и с другого конца).

## Реализация

### Инициализация

Представим граф как двухмерных массив.
Каждое ребро будет массивом из двух элементов (вершин):
ребро из вершины `i` в вершины `j` запишем как `[i, j]`.
Сам граф будет массивом рёбер, например
```js
[
  [0, 1],
  [1, 2],
  [1, 3],
]
```

### Обход

Для реализации чуть более удобным является обход в глубину.

```js
const MAXN = 1000; // Задаём максимальное количество вершин (можно убрать, если не нужно)

const n = ...; // число вершин
const g = new Array(MAXN).fill(null).map(() => []); // массив списков смежности
const visited = new Array(MAXN).fill(false); // массив посещённых вершин
const comp = []; // текущая компонент связности

function dfs(v) {
  visited[v] = true;
  comp.push(v);
  for (let i = 0; i < g[v].length; i++) {
    let to = g[v][i];
  
    if (!visited[to]) {
      dfs(to);
    }
  }
}

function findComps() {
  visited.fill(false); // инициализируем массив посещений

  for (let i = 0; i < n; i++) {
    if (!visited[i]) {
      comp = [];
      dfs(i);

      console.log("Component:", comp.join(" "));
    }
  }
}
```
