# Поиск в ширину

Поиск в ширину (обход в ширину, BFS, Breadth-First Search) — один из базовых алгоритмов работы с графами.

Поиск в ширину находит кратчайший путь в невзвешенном графе, то есть путь с минимальным количеством рёбер.

Алгоритм выполняется за `O (n+m)`, где `n` — число вершин, `m` — число рёбер.

## Описание алгоритма

Алгоритм принимает на вход невзвешенный граф и номер стартовой вершины `s`.
Граф может быть как ориентированным, так и неориентированным — это не влияет на работу алгоритма.

Алгоритм можно представить как процесс «поджигания» графа:
на нулевом шаге загорается только стартовая вершина `s`.
На каждом последующем шаге огонь распространяется от уже горящих вершин на всех их соседей.
Таким образом, за одну итерацию «кольцо огня» расширяется на единицу, охватывая всё больше вершин.
Отсюда и название алгоритма — поиск в ширину.

Более формально алгоритм можно описать так: создадим очередь `queue`,
в которую будут добавляться «горящие» вершины, и булевый массив `visited`,
где для каждой вершины будем отмечать, была ли она уже посещена (то есть «горит» ли она).

Изначально в очередь добавляется только стартовая вершина `s`, при этом `visited[s] = true`,
а для всех остальных вершин `visited[] = false`.
Далее алгоритм выполняется в цикле: пока очередь не пуста, извлекаем из её головы вершину,
просматриваем все рёбра, исходящие из неё, и, если какая-то из смежных вершин ещё не была посещена,
помечаем её как «горящую» (устанавливаем `visited[] = true`) и добавляем в конец очереди.

В результате, когда очередь станет пустой, поиск в ширину обойдет все вершины, достижимые из `s`,
причём каждая из них будет посещена по кратчайшему пути.

Дополнительно алгоритм позволяет вычислить длины кратчайших путей,
для чего достаточно завести массив `d`,
где `d[v]` будет хранить длину кратчайшего пути от `s` до вершины `v`.

Также можно сохранить информацию, необходимую для восстановления этих путей,
используя массив «предков» `p[]`.
В нём для каждой вершины `v` будет храниться вершина,
из которой мы в неё попали, что позволит восстановить путь от `s` до любой достижимой вершины.

## Реализация

Реализуем вышеописанный алгоритм на языке JavaScript.

### Инициализация

Представим граф как двухмерных массив.
Каждое ребро будет массивом из двух элементов (вершин):
ребро из вершины `i` в вершины `j` запишем как `[i, j]`.
Сам граф будет массивом рёбер, например
```js
[
  [0, 1],
  [1, 2],
  [1, 3],
]
```

Подготавливаем переменные и записываем в них данные любым удобным вам образом
```js
const g = ...; // граф
const n = ...; // число вершин
const s = ...; // стартовая вершина (вершины везде нумеруются с нуля)
```

### Обход

```js
const queue = []; // очередь

queue.push(s); // добавляем стартовую вершину

const visited = new Array(n).fill(false); // массив посещённых вершин
const d = new Array(n).fill(0); // расстояния от стартовой вершины
const p = new Array(n).fill(-1); // массив предков для восстановления пути

visited[s] = true;

while (queue.length > 0) {
  const v = queue.shift(); // извлекаем элемент из очереди
    
  for (let i = 0; i < g[v].length; i++) {
    let to = g[v][i];
        
    if (!visited[to]) {
      visited[to] = true;
      queue.push(to);
      d[to] = d[v] + 1;
      p[to] = v;
    }
  }
}
```

Чтобы восстановить и вывести кратчайший путь до вершины `t`,
можно использовать следующий подход:

Начинаем с вершины `t`. Проходим по массиву предков `p[]`,
переходя от вершины `t` к её предку, затем к предку предка, и так далее,
пока не дойдём до стартовой вершины `s`.
Все эти вершины записываются в путь, но в обратном порядке,
поэтому в конце нужно инвертировать полученную последовательность.
Выводим путь, начиная с вершины `s` и заканчивая вершиной `to`.

Таким образом, восстановление пути сводится к последовательному следованию
по массиву предков и инвертированию полученной цепочки вершин.

```js
if (!visited[t]) {
  console.log('Нет пути');
} else {
  const path = [];
    
  for (let v = t; v !== -1; v = p[v]) {
    path.push(v);
  }
    
  path.reverse(); // переворачиваем путь
    
  console.log(path.join());
}
```

## Применение

### Поиск кратчайшего пути в невзвешенном графе.

### Поиск компонент связности в графе за `O(n+m)`.

Для поиска компонент связности в графе мы выполняем обход в ширину,
начиная от каждой вершины, которая ещё не была посещена.
Вместо того чтобы сбрасывать массив посещённых вершин после каждого обхода,
мы просто продолжаем использовать его, что позволяет эффективно обходить новые компоненты связности.
Каждый запуск обхода в ширину охватывает только одну компоненту связности,
и таким образом алгоритм остаётся эффективным, выполняясь за время `O(n+m)`,
где `n` — количество вершин, а `m` — количество рёбер в графе.

Этот метод, при котором несколько запусков обхода происходят без обнуления массива посещённых вершин,
называется серией обходов в ширину.

### Кратчайший путь в 0-1 графе

Для нахождения кратчайшего пути в 0-1-графе (графе, где рёбра имеют веса 0 или 1),
достаточно немного модифицировать стандартный поиск в ширину.

Основные изменения:

Если текущее ребро имеет вес 0, и происходит улучшение расстояния до вершины,
то эту вершину нужно добавить в начало очереди.

Если же ребро имеет вес 1, вершину добавляем в конец очереди.
Эта модификация позволяет эффективно находить кратчайшие пути в графах с такими ограниченными весами,
улучшая работу алгоритма. Время работы этого метода остаётся `O(n+m)`, где `n` — количество вершин,
а `m` — количество рёбер в графе,
так как каждая вершина и ребро обрабатываются не более одного раза.

Такой подход называется обходом в ширину с двухсторонней очередью (deque).

### Нахождение кратчайшего цикла в ориентированном невзвешенном графе

Шаги алгоритма:

* Для каждой вершины выполняем поиск в ширину.
* Во время обхода, если мы пытаемся пройти по ребру в уже посещённую вершину, это значит, что мы нашли цикл. 
* Как только такой цикл найден, прекращаем текущий обход и сохраняем его длину. 
* Повторяем этот процесс для всех вершин. 
* Среди всех найденных циклов выбираем кратчайший.

### Поиск рёбер, лежащих на каком-либо кратчайшем пути

Для этого надо запустить два поиска в ширину: из вершины `a` и вершины `b`.

Обозначим через `da[]` массив кратчайших расстояний,
полученный в результате первого обхода,
а через `db[]` — в результате второго обхода.

Теперь для любого ребра `(u,v)` легко проверить,
лежит ли он на каком-либо кратчайшем пути:
критерием будет условие `da[u] + 1 + db[v] = da[b]`.

### Поиск вершин, лежащих на каком-либо кратчайшем пути

Для этого надо запустить два поиска в ширину: из вершины `a` и вершины `b`.

Обозначим через `da[]` массив кратчайших расстояний,
полученный в результате первого обхода,
а через `db[]` — в результате второго обхода.

Теперь для любой вершины `v` легко проверить,
лежит ли она на каком-либо кратчайшем пути:
критерием будет условие `da[v] + db[v] = da[b]`.

### Поиск кратчайшего чётного пути

Для этого надо построить вспомогательный граф, вершинами которого будут состояния `(v,c)`,
где `v` — номер текущей вершины, `c = 0 ... 1` — текущая чётность.

Любое ребро `(a,b)` исходного графа в этом новом графе
превратится в два ребра `((u,0),(v,1)) и ((u,1),(v,0))`.
После этого на этом графе надо обходом в ширину найти кратчайший путь
из стартовой вершины в конечную, с чётностью, равной 0.
