# Поиск в ширину

Поиск в ширину (обход в ширину, BFS, Breadth-First Search) — один из базовых алгоритмов работы с графами.

Поиск в ширину находит кратчайший путь в невзвешенном графе, то есть путь с минимальным количеством рёбер.

Алгоритм выполняется за `O (n+m)`, где `n` — число вершин, `m` — число рёбер.

## Описание алгоритма

Алгоритм принимает на вход невзвешенный граф и номер стартовой вершины `s`.
Граф может быть как ориентированным, так и неориентированным — это не влияет на работу алгоритма.

Алгоритм можно представить как процесс «поджигания» графа:
на нулевом шаге загорается только стартовая вершина `s`.
На каждом последующем шаге огонь распространяется от уже горящих вершин на всех их соседей.
Таким образом, за одну итерацию «кольцо огня» расширяется на единицу, охватывая всё больше вершин.
Отсюда и название алгоритма — поиск в ширину.

Более формально алгоритм можно описать так: создадим очередь `queue`,
в которую будут добавляться «горящие» вершины, и булевый массив `visited`,
где для каждой вершины будем отмечать, была ли она уже посещена (то есть «горит» ли она).

Изначально в очередь добавляется только стартовая вершина `s`, при этом `visited[s] = true`,
а для всех остальных вершин `visited[] = false`.
Далее алгоритм выполняется в цикле: пока очередь не пуста, извлекаем из её головы вершину,
просматриваем все рёбра, исходящие из неё, и, если какая-то из смежных вершин ещё не была посещена,
помечаем её как «горящую» (устанавливаем `visited[] = true`) и добавляем в конец очереди.

В результате, когда очередь станет пустой, поиск в ширину обойдет все вершины, достижимые из `s`,
причём каждая из них будет посещена по кратчайшему пути.

Дополнительно алгоритм позволяет вычислить длины кратчайших путей,
для чего достаточно завести массив `d`,
где `d[v]` будет хранить длину кратчайшего пути от `s` до вершины `v`.

Также можно сохранить информацию, необходимую для восстановления этих путей,
используя массив «предков» `p[]`.
В нём для каждой вершины `v` будет храниться вершина,
из которой мы в неё попали, что позволит восстановить путь от `s` до любой достижимой вершины.

## Реализация

Реализуем вышеописанный алгоритм на языке JavaScript.

### Инициализация

Представим граф как двухмерных массив.
Каждое ребро будет массивом из двух элементов (вершин):
ребро из вершины `i` в вершины `j` запишем как `[i, j]`.
Сам граф будет массивом рёбер, например
```js
[
  [0, 1],
  [1, 2],
  [1, 3],
]
```

Подготавливаем переменные и записываем в них данные любым удобным вам образом
```js
const g = ...; // граф
const n = ...; // число вершин
const s = ...; // стартовая вершина (вершины везде нумеруются с нуля)
```

### Обход

```js
const queue = []; // очередь

queue.push(s); // добавляем стартовую вершину

const visited = new Array(n).fill(false); // массив посещённых вершин
const d = new Array(n).fill(0); // расстояния от стартовой вершины
const p = new Array(n).fill(-1); // массив предков для восстановления пути

visited[s] = true;

while (queue.length > 0) {
  const v = queue.shift(); // извлекаем элемент из очереди
    
  for (let i = 0; i < g[v].length; i++) {
    let to = g[v][i];
        
    if (!visited[to]) {
      visited[to] = true;
      queue.push(to);
      d[to] = d[v] + 1;
      p[to] = v;
    }
  }
}
```

Чтобы восстановить и вывести кратчайший путь до вершины `t`,
можно использовать следующий подход:

Начинаем с вершины `t`. Проходим по массиву предков `p[]`,
переходя от вершины `t` к её предку, затем к предку предка, и так далее,
пока не дойдём до стартовой вершины `s`.
Все эти вершины записываются в путь, но в обратном порядке,
поэтому в конце нужно инвертировать полученную последовательность.
Выводим путь, начиная с вершины `s` и заканчивая вершиной `to`.

Таким образом, восстановление пути сводится к последовательному следованию
по массиву предков и инвертированию полученной цепочки вершин.

```js
if (!visited[t]) {
  console.log('Нет пути');
} else {
  const path = [];
    
  for (let v = t; v !== -1; v = p[v]) {
    path.push(v);
  }
    
  path.reverse(); // переворачиваем путь
    
  console.log(path.join());
}
```
